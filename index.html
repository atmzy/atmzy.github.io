<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>hello</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="note something">
<meta property="og:type" content="website">
<meta property="og:title" content="hello">
<meta property="og:url" content="http://atmzy.github.io/index.html">
<meta property="og:site_name" content="hello">
<meta property="og:description" content="note something">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hello">
<meta name="twitter:description" content="note something">
  
    <link rel="alternate" href="/atom.xml" title="hello" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">hello</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">world</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://atmzy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-动态加载dex-jar文件过程分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/27/动态加载dex-jar文件过程分析/" class="article-date">
  <time datetime="2017-02-27T12:20:18.000Z" itemprop="datePublished">2017-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/27/动态加载dex-jar文件过程分析/">动态加载dex/jar文件过程分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&#160; &#160; &#160; &#160;Android系统中由dalvik虚拟机负责动态加载动作的执行，具体的源文件主要在源码目录中/libcore/dalvik/src/main/java/dalvik/system/路径下。</p>
<h1 id="1、dex文件载入过程"><a href="#1、dex文件载入过程" class="headerlink" title="1、dex文件载入过程"></a>1、dex文件载入过程</h1><p>&#160; &#160; &#160; &#160;先看最常用的动态加载dex文件的方法，首先创建一个DexClassLoader对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">55    public DexClassLoader(String dexPath, String optimizedDirectory,</div><div class="line">56            String libraryPath, ClassLoader parent) &#123;</div><div class="line">57        super(dexPath, new File(optimizedDirectory), libraryPath, parent);</div><div class="line">58    &#125;</div><div class="line">（/libcore/dalvik/src/main/java/dalvik/system/DexClassLoader.java）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;构造它的时候传入了四个参数。dexPath是要加载的文件路径，可以为多个文件的列表，用“:”分隔；optimizedDirectory是用来存放优化后的dex文件的目录；libraryPath是存放可能需要用到的native库的目录，同样可以为多个目录的列表，用“:”分隔，如果没有的话这个参数可以为null；parent是给定的这个新生成的class loader的父class loader，对于dexclassloader，它的父classloader应该是pathclassloader，具体有什么用稍后再说。其实什么也没有干，看样子操作应该是在它的父类中。那再看一下它的父类BaseDexClassLoader的构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">45    public BaseDexClassLoader(String dexPath, File optimizedDirectory,</div><div class="line">46            String libraryPath, ClassLoader parent) &#123;</div><div class="line">47        super(parent);</div><div class="line">48        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);</div><div class="line">49    &#125;</div><div class="line">（/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;然而也没有干什么，只是创建了一个pathList对象。这个东西其实就是个用来存放前面说的dexPath和libraryPath两个参数所传入的文件和目录的辅助工具，如果是文件就将其载入内存，如果是目录则仅仅只是记录下来。每个class loader都含有一个对应的pathList，其中封装了一些操作函数，具体实现后面用到再详细看。这样一个dex/jar/zip/apk文件的载入过程就结束了，好像啥也没做的说呢= =</p>
<h1 id="2、class载入过程"><a href="#2、class载入过程" class="headerlink" title="2、class载入过程"></a>2、class载入过程</h1><p>&#160; &#160; &#160; &#160;当成功获取一个class loader对象之后，就可以载入其中所含有的类的具体内容了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">468    public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123;</div><div class="line">469        return loadClass(className, false);</div><div class="line">470    &#125;</div><div class="line">……</div><div class="line">498    protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</div><div class="line">499        Class&lt;?&gt; clazz = findLoadedClass(className);</div><div class="line">500</div><div class="line">501        if (clazz == null) &#123;</div><div class="line">502            ClassNotFoundException suppressed = null;</div><div class="line">503            try &#123;</div><div class="line">504                clazz = parent.loadClass(className, false);</div><div class="line">505            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">506                suppressed = e;</div><div class="line">507            &#125;</div><div class="line">508</div><div class="line">509            if (clazz == null) &#123;</div><div class="line">510                try &#123;</div><div class="line">511                    clazz = findClass(className);</div><div class="line">512                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">513                    e.addSuppressed(suppressed);</div><div class="line">514                    throw e;</div><div class="line">515                &#125;</div><div class="line">516            &#125;</div><div class="line">517        &#125;</div><div class="line">518</div><div class="line">519        return clazz;</div><div class="line">520    &#125;</div><div class="line">(/libcore/libart/src/main/java/java/lang/ClassLoader.java)</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;Class loader根据className来寻找对应的class，第二个方法中的resolve参数是用来设置是否解析这个class，但是在Android中这个参数是被忽略掉的，从来都不解析被载入的class。</p>
<p>&#160; &#160; &#160; &#160;这里首先解释一下加载class的大概流程，首先会从dalvik虚拟机中已加载的class中去寻找，如果没有找到则尝试使用父class loader加载该class，如果还是加载不成功，再从自己的dexpathlist中去查找该class，如果查找不到到就抛出ClassNotFoundException异常。</p>
<p>&#160; &#160; &#160; &#160;先看如何查找已加载的class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">356    protected final Class&lt;?&gt; findLoadedClass(String className) &#123;</div><div class="line">357        ClassLoader loader;</div><div class="line">358        if (this == BootClassLoader.getInstance())</div><div class="line">359            loader = null;</div><div class="line">360        else</div><div class="line">361            loader = this;</div><div class="line">362        return VMClassLoader.findLoadedClass(loader, className);</div><div class="line">363    &#125;</div><div class="line">(/libcore/libart/src/main/java/java/lang/ClassLoader.java)</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这个时候首先会判断当前的class loader是否为BootClassLoader，如果是的话就用null来调用VMClassLoader.findLoadedClass。继续跟进去看发现这个findLoadClass的具体实现是在native层的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">27  static jclass VMClassLoader_findLoadedClass(JNIEnv* env, jclass, jobject javaLoader, jstring javaName) &#123;</div><div class="line">28  ScopedFastNativeObjectAccess soa(env);</div><div class="line">29  mirror::ClassLoader* loader = soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader);</div><div class="line">30  ScopedUtfChars name(env, javaName);</div><div class="line">31  if (name.c_str() == nullptr) &#123;</div><div class="line">32    return nullptr;</div><div class="line">33  &#125;</div><div class="line">34  ClassLinker* cl = Runtime::Current()-&gt;GetClassLinker();</div><div class="line">35  std::string descriptor(DotToDescriptor(name.c_str()));</div><div class="line">36  const size_t descriptor_hash = ComputeModifiedUtf8Hash(descriptor.c_str());</div><div class="line">37  mirror::Class* c = cl-&gt;LookupClass(descriptor.c_str(), descriptor_hash, loader);</div><div class="line">38  if (c != nullptr &amp;&amp; c-&gt;IsResolved()) &#123;</div><div class="line">39    return soa.AddLocalReference&lt;jclass&gt;(c);</div><div class="line">40  &#125;</div><div class="line">41  if (loader != nullptr) &#123;</div><div class="line">42    // Try the common case.</div><div class="line">43    StackHandleScope&lt;1&gt; hs(soa.Self());</div><div class="line">44    c = cl-&gt;FindClassInPathClassLoader(soa, soa.Self(), descriptor.c_str(), descriptor_hash,</div><div class="line">45                                       hs.NewHandle(loader));</div><div class="line">46    if (c != nullptr) &#123;</div><div class="line">47      return soa.AddLocalReference&lt;jclass&gt;(c);</div><div class="line">48    &#125;</div><div class="line">49  &#125;</div><div class="line">50  // Class wasn&apos;t resolved so it may be erroneous or not yet ready, force the caller to go into</div><div class="line">51  // the regular loadClass code.</div><div class="line">52  return nullptr;</div><div class="line">53&#125;</div><div class="line">（/art/runtime/native/java_lang_VMClassLoader.cc）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;首先判断javaName为null则直接返回。然后获取一个ClassLinker对象cl，ClassLinker对象是再创建ART虚拟机的过程中创建的，用来加载类以及链接类方法。首先直接调用cl的LookupClass方法来寻找目标class，如果找到就直接返回结果。否则的话再判断loader对象是否为null，如果不为null说明在之前的Java层中的class loader不是BootClassLoader，那么就使用FindClassInPathClassLoader利用loader对象来寻找目标class。</p>
<p>&#160; &#160; &#160; &#160;首先先看第一步的LookupClass方法的具体实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">3348  mirror::Class* ClassLinker::LookupClass(const char* descriptor, size_t hash,</div><div class="line">3349                                        mirror::ClassLoader* class_loader) &#123;</div><div class="line">3350  &#123;</div><div class="line">3351    ReaderMutexLock mu(Thread::Current(), *Locks::classlinker_classes_lock_);</div><div class="line">3352    mirror::Class* result = LookupClassFromTableLocked(descriptor, class_loader, hash);</div><div class="line">3353    if (result != nullptr) &#123;</div><div class="line">3354      return result;</div><div class="line">3355    &#125;</div><div class="line">3356  &#125;</div><div class="line">3357  if (class_loader != nullptr || !dex_cache_image_class_lookup_required_) &#123;</div><div class="line">3358    return nullptr;</div><div class="line">3359  &#125; else &#123;</div><div class="line">3360    // Lookup failed but need to search dex_caches_.</div><div class="line">3361    mirror::Class* result = LookupClassFromImage(descriptor);</div><div class="line">3362    if (result != nullptr) &#123;</div><div class="line">3363      InsertClass(descriptor, result, hash);</div><div class="line">3364    &#125; else &#123;</div><div class="line">3365      // Searching the image dex files/caches failed, we don&apos;t want to get into this situation</div><div class="line">3366      // often as map searches are faster, so after kMaxFailedDexCacheLookups move all image</div><div class="line">3367      // classes into the class table.</div><div class="line">3368      constexpr uint32_t kMaxFailedDexCacheLookups = 1000;</div><div class="line">3369      if (++failed_dex_cache_class_lookups_ &gt; kMaxFailedDexCacheLookups) &#123;</div><div class="line">3370        MoveImageClassesToClassTable();</div><div class="line">3371      &#125;</div><div class="line">3372    &#125;</div><div class="line">3373    return result;</div><div class="line">3374  &#125;</div><div class="line">3375&#125;</div><div class="line"></div><div class="line">3377mirror::Class* ClassLinker::LookupClassFromTableLocked(const char* descriptor,</div><div class="line">3378                                                       mirror::ClassLoader* class_loader,</div><div class="line">3379                                                       size_t hash) &#123;</div><div class="line">3380  auto descriptor_pair = std::make_pair(descriptor, class_loader);</div><div class="line">3381  auto it = pre_zygote_class_table_.FindWithHash(descriptor_pair, hash);</div><div class="line">3382  if (it == pre_zygote_class_table_.end()) &#123;</div><div class="line">3383    it = class_table_.FindWithHash(descriptor_pair, hash);</div><div class="line">3384    if (it == class_table_.end()) &#123;</div><div class="line">3385      return nullptr;</div><div class="line">3386    &#125;</div><div class="line">3387  &#125;</div><div class="line">3388  return it-&gt;Read();</div><div class="line">3389&#125;</div><div class="line"></div><div class="line">（/art/runtime/class_linker.cc）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在classlinker中寻找目标class时会分为两个步骤，先从缓存的pre_zygote_class<em>table</em>、和class<em>table</em>两个table中寻找，如果没找到，则判断class_loader为null和dex_cache_image_class_lookup<em>required</em>为false，如果二者中有一个成立，则不再搜索，直接退出。这里class_loader不为null直接退出的原因是因为class_loader不为null则表示当前的classloader不是bootclassloader，所以没有必要检索Image中的class，因为只需要在bootclassloader中对Image中的class检索一次即可，其他的classloader就不需要再进行重复的操作了。而且如果要在bootclassloader中检索Image中的class，首先会确认该class是否存在与boot_class<em>path</em>，如果没有找到的话也不会进行该操作。dex_cache_image_class_lookup<em>required</em>为false的原因是为了避免不必要的时间消耗，如果调用LookupClassFromImage方法从Image中寻找class失败的次数过多（超过1000次），则会调用MoveImageClassesToClassTable，直接将Image中所有的classes导入到class<em>table</em>中，并将dex_cache_image_class_lookup<em>required</em>的值设定为false，这样下次如果在LookupClassFromTableLocked中寻找class失败，并且遇到该变量值为false时就可以知道不需要再去image中寻找目标class了。<br>至于具体的更加深入的pre_zygote_class<em>table</em>、和class<em>table</em>两个table是如何生成及维护的，Image中class具体有哪些类别就不再向下探究了，这些属于ART运行时部分的内容。</p>
<p>&#160; &#160; &#160; &#160;接下来回到上一步的第二个处理步骤，使用FindClassInPathClassLoader利用loader对象来寻找目标class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">2031  mirror::Class* ClassLinker::FindClassInPathClassLoader(ScopedObjectAccessAlreadyRunnable&amp; soa,</div><div class="line">2032                                                       Thread* self, const char* descriptor,</div><div class="line">2033                                                       size_t hash,</div><div class="line">2034                                                       Handle&lt;mirror::ClassLoader&gt; class_loader) &#123;</div><div class="line">2035  if (class_loader-&gt;GetClass() !=</div><div class="line">2036      soa.Decode&lt;mirror::Class*&gt;(WellKnownClasses::dalvik_system_PathClassLoader) ||</div><div class="line">2037      class_loader-&gt;GetParent()-&gt;GetClass() !=</div><div class="line">2038          soa.Decode&lt;mirror::Class*&gt;(WellKnownClasses::java_lang_BootClassLoader)) &#123;</div><div class="line">2039    return nullptr;</div><div class="line">2040  &#125;</div><div class="line">2041  ClassPathEntry pair = FindInClassPath(descriptor, hash, boot_class_path_);</div><div class="line">2042  // Check if this would be found in the parent boot class loader.</div><div class="line">2043  if (pair.second != nullptr) &#123;</div><div class="line">2044    mirror::Class* klass = LookupClass(descriptor, hash, nullptr);</div><div class="line">2045    if (klass != nullptr) &#123;</div><div class="line">2046      return EnsureResolved(self, descriptor, klass);</div><div class="line">2047    &#125;</div><div class="line">2048    klass = DefineClass(self, descriptor, hash, NullHandle&lt;mirror::ClassLoader&gt;(), *pair.first,</div><div class="line">2049                        *pair.second);</div><div class="line">2050    if (klass != nullptr) &#123;</div><div class="line">2051      return klass;</div><div class="line">2052    &#125;</div><div class="line">2053    CHECK(self-&gt;IsExceptionPending()) &lt;&lt; descriptor;</div><div class="line">2054    self-&gt;ClearException();</div><div class="line">2055  &#125; else &#123;</div><div class="line">2056    // RegisterDexFile may allocate dex caches (and cause thread suspension).</div><div class="line">2057    StackHandleScope&lt;3&gt; hs(self);</div><div class="line">2058    // The class loader is a PathClassLoader which inherits from BaseDexClassLoader.</div><div class="line">2059    // We need to get the DexPathList and loop through it.</div><div class="line">2060    Handle&lt;mirror::ArtField&gt; cookie_field =</div><div class="line">2061        hs.NewHandle(soa.DecodeField(WellKnownClasses::dalvik_system_DexFile_cookie));</div><div class="line">2062    Handle&lt;mirror::ArtField&gt; dex_file_field =</div><div class="line">2063        hs.NewHandle(</div><div class="line">2064            soa.DecodeField(WellKnownClasses::dalvik_system_DexPathList$Element_dexFile));</div><div class="line">2065    mirror::Object* dex_path_list =</div><div class="line">2066        soa.DecodeField(WellKnownClasses::dalvik_system_PathClassLoader_pathList)-&gt;</div><div class="line">2067        GetObject(class_loader.Get());</div><div class="line">2068    if (dex_path_list != nullptr &amp;&amp; dex_file_field.Get() != nullptr &amp;&amp;</div><div class="line">2069        cookie_field.Get() != nullptr) &#123;</div><div class="line">2070      // DexPathList has an array dexElements of Elements[] which each contain a dex file.</div><div class="line">2071      mirror::Object* dex_elements_obj =</div><div class="line">2072          soa.DecodeField(WellKnownClasses::dalvik_system_DexPathList_dexElements)-&gt;</div><div class="line">2073          GetObject(dex_path_list);</div><div class="line">2074      // Loop through each dalvik.system.DexPathList$Element&apos;s dalvik.system.DexFile and look</div><div class="line">2075      // at the mCookie which is a DexFile vector.</div><div class="line">2076      if (dex_elements_obj != nullptr) &#123;</div><div class="line">2077        Handle&lt;mirror::ObjectArray&lt;mirror::Object&gt;&gt; dex_elements =</div><div class="line">2078            hs.NewHandle(dex_elements_obj-&gt;AsObjectArray&lt;mirror::Object&gt;());</div><div class="line">2079        for (int32_t i = 0; i &lt; dex_elements-&gt;GetLength(); ++i) &#123;</div><div class="line">2080          mirror::Object* element = dex_elements-&gt;GetWithoutChecks(i);</div><div class="line">2081          if (element == nullptr) &#123;</div><div class="line">2082            // Should never happen, fall back to java code to throw a NPE.</div><div class="line">2083            break;</div><div class="line">2084          &#125;</div><div class="line">2085          mirror::Object* dex_file = dex_file_field-&gt;GetObject(element);</div><div class="line">2086          if (dex_file != nullptr) &#123;</div><div class="line">2087            const uint64_t cookie = cookie_field-&gt;GetLong(dex_file);</div><div class="line">2088            auto* dex_files =</div><div class="line">2089                reinterpret_cast&lt;std::vector&lt;const DexFile*&gt;*&gt;(static_cast&lt;uintptr_t&gt;(cookie));</div><div class="line">2090            if (dex_files == nullptr) &#123;</div><div class="line">2091              // This should never happen so log a warning.</div><div class="line">2092              LOG(WARNING) &lt;&lt; &quot;Null DexFile::mCookie for &quot; &lt;&lt; descriptor;</div><div class="line">2093              break;</div><div class="line">2094            &#125;</div><div class="line">2095            for (const DexFile* dex_file : *dex_files) &#123;</div><div class="line">2096              const DexFile::ClassDef* dex_class_def = dex_file-&gt;FindClassDef(descriptor, hash);</div><div class="line">2097              if (dex_class_def != nullptr) &#123;</div><div class="line">2098                RegisterDexFile(*dex_file);</div><div class="line">2099                mirror::Class* klass = DefineClass(self, descriptor, hash, class_loader, *dex_file,</div><div class="line">2100                                                   *dex_class_def);</div><div class="line">2101                if (klass == nullptr) &#123;</div><div class="line">2102                  CHECK(self-&gt;IsExceptionPending()) &lt;&lt; descriptor;</div><div class="line">2103                  self-&gt;ClearException();</div><div class="line">2104                  return nullptr;</div><div class="line">2105                &#125;</div><div class="line">2106                return klass;</div><div class="line">2107              &#125;</div><div class="line">2108            &#125;</div><div class="line">2109          &#125;</div><div class="line">2110        &#125;</div><div class="line">2111      &#125;</div><div class="line">2112    &#125;</div><div class="line">2113  &#125;</div><div class="line">2114  return nullptr;</div><div class="line">2115&#125;</div><div class="line">（/art/runtime/class_linker.cc）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;简要看一下这部分的流程，首先需要判断当前的class_loader是不是pathclassLoader，而且还要判断class_loader的附class loader是不是bootclassloader，如果有一个条件不满足就直接退出。然后从boot_class_path中查找目标class，如果能够找到的话就说明该class应该是属于Image中的一个，所以以第三个参数为null调用LookupClass方法，即以boot class loader的身份来查找这个class，然后返回该class。如果没找到的话就调用DefineClass方法来初始化这个class，成功的话将结果返回。</p>
<p>&#160; &#160; &#160; &#160;如果从boot_class_path没有找到目标class，那么就需要重新注册这个dex文件，需要从这个pathclassloader的dexpathlist对象中的dexElements成员中一个一个解析其中保存的dex文件，如果有符合的则调用DefineClass方法来初始化这个class，成功的话将结果返回。</p>
<p>&#160; &#160; &#160; &#160;到这里上面的VMClassLoader_findLoadedClass方法就已经执行完了，如果经过上面叙述的LookupClass和FindClassInPathClassLoader两个方法都没有找到目标class，那就是确实找不到了，返回null。</p>
<p>&#160; &#160; &#160; &#160;经过loadClass中的findLoadedClass方法后，如果没有找到该class，那就说明这个class以前还没有加载过，那么就调用父class loader的loadClass执行一次寻找目标class的动作。具体的执行过程当然跟上面分析的是一样的，只是由于每次执行的身份不同会产生不同的具体动作。</p>
<p>&#160; &#160; &#160; &#160;为了清楚执行loadClass时到底有几个class loader的身份，以及它们之间的关系爱，这里要对各个class loader的父子关系进行一下梳理。</p>
<p>&#160; &#160; &#160; &#160;首先，系统中最开始产生的一个class loader是BootClassLoader，该类的代码在/libcore/libart/src/main/java/java/lang/ClassLoader.java文件中，它是其他所有class loader的根节点。然后，我们在应用中希望生成一个DexClassLoader对象时，需要传入一个parent对象作为其父class loader，在没有其他class loader对象的时候，需要使用context中的getClassLoader()方法来获得第一个class loader。而这里最终返回的是一个PathClassLoader。具体执行过程如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">849    @Override</div><div class="line">850    public ClassLoader getClassLoader() &#123;</div><div class="line">851        return mPackageInfo != null ?</div><div class="line">852                mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</div><div class="line">853    &#125;</div><div class="line">（/frameworks/base/core/java/android/app/ContextImpl.java）</div><div class="line"></div><div class="line">136    public static ClassLoader getSystemClassLoader() &#123;</div><div class="line">137        return SystemClassLoader.loader;</div><div class="line">138    &#125;</div><div class="line"></div><div class="line">80    static private class SystemClassLoader &#123;</div><div class="line">81        public static ClassLoader loader = ClassLoader.createSystemClassLoader();</div><div class="line">82    &#125;</div><div class="line"></div><div class="line">111    private static ClassLoader createSystemClassLoader() &#123;</div><div class="line">112        String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;);</div><div class="line">113</div><div class="line">……</div><div class="line">128        return new PathClassLoader(classPath, BootClassLoader.getInstance());</div><div class="line">129    &#125;</div><div class="line">(/libcore/libart/src/main/java/java/lang/ClassLoader.java)</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;这里的pathclassloader是一个静态单例，所有执行getClassLoader()的应用获取的都是同一个pathclassloader对象。也就是说，其实class loader的生成顺序是bootclassloader-&gt;pathclassloader-&gt;dexclassloader，而真正有多个不同对象存在的就只有dexclassloader，前面两个在整个系统中都只存在一个。大概的关系如下图所示。</p>
<p> <img src="https://github.com/atmzy/atmzy.github.io/blob/master/ClassLoader%E6%95%B4%E4%BD%93%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg?raw=true" alt="ClassLoader整体关系图"></p>
<p>&#160; &#160; &#160; &#160;然后继续说上面的loadClass()的部分。前面分析的过程可以看做先从当前class loader和父class loader中找有没有家再过目标class，即下面方框中的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">498    protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123;</div><div class="line">499        Class&lt;?&gt; clazz = findLoadedClass(className);</div><div class="line">500</div><div class="line">501        if (clazz == null) &#123;</div><div class="line">502            ClassNotFoundException suppressed = null;</div><div class="line">503            try &#123;</div><div class="line">504                clazz = parent.loadClass(className, false);</div><div class="line">505            &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">506                suppressed = e;</div><div class="line">507            &#125;</div><div class="line">508</div><div class="line">509            if (clazz == null) &#123;</div><div class="line">510                try &#123;</div><div class="line">511                    clazz = findClass(className);</div><div class="line">512                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">513                    e.addSuppressed(suppressed);</div><div class="line">514                    throw e;</div><div class="line">515                &#125;</div><div class="line">516            &#125;</div><div class="line">517        &#125;</div><div class="line">518</div><div class="line">519        return clazz;</div><div class="line">520    &#125;</div><div class="line">（/libcore/libart/src/main/java/java/lang/ClassLoader.java）</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;发现没有找到后，则从调用自己的findClass()方法。这个方法在ClassLoader类中声明，在BaseDexClassLoader中实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">51    @Override</div><div class="line">52    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">53        List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;();</div><div class="line">54        Class c = pathList.findClass(name, suppressedExceptions);</div><div class="line">55        if (c == null) &#123;</div><div class="line">56            ClassNotFoundException cnfe = new ClassNotFoundException(&quot;Didn&apos;t find class \&quot;&quot; + name + &quot;\&quot; on path: &quot; + pathList);</div><div class="line">57            for (Throwable t : suppressedExceptions) &#123;</div><div class="line">58                cnfe.addSuppressed(t);</div><div class="line">59            &#125;</div><div class="line">60            throw cnfe;</div><div class="line">61        &#125;</div><div class="line">62        return c;</div><div class="line">63    &#125;</div><div class="line">（/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在这里直接调用了pathList中的findClass，pathList前面在说明dex文件载入过程的时候提到了，是一个DexPathList对象，其中保存了当前class loader中所载入的一系列资源文件，并且提供了一些操作方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">316    public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</div><div class="line">317        for (Element element : dexElements) &#123;</div><div class="line">318            DexFile dex = element.dexFile;</div><div class="line">319</div><div class="line">320            if (dex != null) &#123;</div><div class="line">321                Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</div><div class="line">322                if (clazz != null) &#123;</div><div class="line">323                    return clazz;</div><div class="line">324                &#125;</div><div class="line">325            &#125;</div><div class="line">326        &#125;</div><div class="line">327        if (dexElementsSuppressedExceptions != null) &#123;</div><div class="line">328            suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</div><div class="line">329        &#125;</div><div class="line">330        return null;</div><div class="line">331    &#125;</div><div class="line">（/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java）</div></pre></td></tr></table></figure></p>
<p>&#160; &#160; &#160; &#160;在DexPathList.findClass()中首先遍历当前存储的dex文件，然后从每个dex文件中寻找目标class，调用的方法名字叫做loadClassBinaryName()。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">218    public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123;</div><div class="line">219        return defineClass(name, loader, mCookie, suppressed);</div><div class="line">220    &#125;</div><div class="line"></div><div class="line">222    private static Class defineClass(String name, ClassLoader loader, long cookie,</div><div class="line">223                                     List&lt;Throwable&gt; suppressed) &#123;</div><div class="line">224        Class result = null;</div><div class="line">225        try &#123;</div><div class="line">226            result = defineClassNative(name, loader, cookie);</div><div class="line">227        &#125; catch (NoClassDefFoundError e) &#123;</div><div class="line">228            if (suppressed != null) &#123;</div><div class="line">229                suppressed.add(e);</div><div class="line">230            &#125;</div><div class="line">231        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">232            if (suppressed != null) &#123;</div><div class="line">233                suppressed.add(e);</div><div class="line">234            &#125;</div><div class="line">235        &#125;</div><div class="line">236        return result;</div><div class="line">237    &#125;</div><div class="line"></div><div class="line">301    private static native Class defineClassNative(String name, ClassLoader loader, long cookie)</div><div class="line">302            throws ClassNotFoundException, NoClassDefFoundError;</div><div class="line">（/libcore/dalvik/src/main/java/dalvik/system/DexFile.java）</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;进入DexFile中看一下发现，loadClassBinaryName真正的名字其实应该是defineClass，即直接在dalvik虚拟机中加载该class，因为前面都已经把家再过的class找遍了也没找到，所以这里直接加载就可以了。最终是调用了defineClassNative进入native层执行具体操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">169  static jclass DexFile_defineClassNative(JNIEnv* env, jclass, jstring javaName, jobject javaLoader,</div><div class="line">170                                        jlong cookie) &#123;</div><div class="line">171  std::vector&lt;const DexFile*&gt;* dex_files = toDexFiles(cookie, env);</div><div class="line">172  if (dex_files == NULL) &#123;</div><div class="line">173    VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_file&quot;;</div><div class="line">174    return NULL;</div><div class="line">175  &#125;</div><div class="line">176  ScopedUtfChars class_name(env, javaName);</div><div class="line">177  if (class_name.c_str() == NULL) &#123;</div><div class="line">178    VLOG(class_linker) &lt;&lt; &quot;Failed to find class_name&quot;;</div><div class="line">179    return NULL;</div><div class="line">180  &#125;</div><div class="line">181  const std::string descriptor(DotToDescriptor(class_name.c_str()));</div><div class="line">182  const size_t hash(ComputeModifiedUtf8Hash(descriptor.c_str()));</div><div class="line">183  for (const DexFile* dex_file : *dex_files) &#123;</div><div class="line">184    const DexFile::ClassDef* dex_class_def = dex_file-&gt;FindClassDef(descriptor.c_str(), hash);</div><div class="line">185    if (dex_class_def != nullptr) &#123;</div><div class="line">186      ScopedObjectAccess soa(env);</div><div class="line">187      ClassLinker* class_linker = Runtime::Current()-&gt;GetClassLinker();</div><div class="line">188      class_linker-&gt;RegisterDexFile(*dex_file);</div><div class="line">189      StackHandleScope&lt;1&gt; hs(soa.Self());</div><div class="line">190      Handle&lt;mirror::ClassLoader&gt; class_loader(</div><div class="line">191          hs.NewHandle(soa.Decode&lt;mirror::ClassLoader*&gt;(javaLoader)));</div><div class="line">192      mirror::Class* result = class_linker-&gt;DefineClass(soa.Self(), descriptor.c_str(), hash,</div><div class="line">193                                                        class_loader, *dex_file, *dex_class_def);</div><div class="line">194      if (result != nullptr) &#123;</div><div class="line">195        VLOG(class_linker) &lt;&lt; &quot;DexFile_defineClassNative returning &quot; &lt;&lt; result;</div><div class="line">196        return soa.AddLocalReference&lt;jclass&gt;(result);</div><div class="line">197      &#125;</div><div class="line">198    &#125;</div><div class="line">199  &#125;</div><div class="line">200  VLOG(class_linker) &lt;&lt; &quot;Failed to find dex_class_def&quot;;</div><div class="line">201  return nullptr;</div><div class="line">202&#125;</div><div class="line">（/art/runtime/native/dalvik_system_DexFile.cc）</div></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;这里加载class的流程与pathclassloader在执行FindClassInPathClassLoader时载入的方法类似，主要就是RegisterDexFile(<em>dex_file)，然后DefineClass(soa.Self(), descriptor.c_str(), hash,                                                 class_loader, </em>dex_file, *dex_class_def)，返回执行结果即可。</p>
<p>&#160; &#160; &#160; &#160;到这里整个loadClass的分析就完成了，总结起来这里的内容有两个重点，一个是class loader的生成顺序也就他们之间的父子关系是bootclassloader-&gt;pathclassloader-&gt;dexclassloader。第二个就是loadClass的时候总是先看是不是已经加载过了，而且是递归的查找，当前没找到还要去它的父class loader里面去找，如果都没找到那么再从当前class loader中的dex文件中去实际加载。之所以这样目的很明显就是为了减少loadClass的时间消耗，因为即使好几个class loader到处找一遍的速度也还是比实际加载一次的速度快，而且考虑到有可能会重复对同一个class执行loadClass多次，显然还是从缓存中查找速度更快。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://atmzy.github.io/2017/02/27/动态加载dex-jar文件过程分析/" data-id="cizo46p560002o0uoojy2gwvp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-APK安装过程中的签名校验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/APK安装过程中的签名校验/" class="article-date">
  <time datetime="2016-10-17T11:12:30.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/APK安装过程中的签名校验/">APK安装过程中的签名校验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="APK安装过程中的签名校验"><a href="#APK安装过程中的签名校验" class="headerlink" title="APK安装过程中的签名校验"></a>APK安装过程中的签名校验</h2><p>系统中所有已经安装的APK信息均保存在一个ArrayMap<string, packageparser.package=""> 之中：</string,></p>
<p>源文件：/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">392    final ArrayMap&lt;String, PackageParser.Package&gt; mPackages =</div><div class="line">393            new ArrayMap&lt;String, PackageParser.Package&gt;();</div></pre></td></tr></table></figure>
<p>在系统启动时会将所有APK信息导入mPackages:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">5278    private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags,</div><div class="line">5279            int scanFlags, long currentTime, UserHandle user) throws PackageManagerException &#123;</div><div class="line">                ...</div><div class="line">6060            // Add the new setting to mPackages</div><div class="line">6061            mPackages.put(pkg.applicationInfo.packageName, pkg);</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>在安装APK时，如果发现现在正在安装的APK在系统中已经存在更早的版本，需要替换这个更早的版本，就会对这两个不同版本的APK的签名进行校验，查看是否相同：</p>
<p>源文件：/frameworks/base/core/java/android/app/ApplicationPackageManager.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">443    @Override</div><div class="line">444    public int checkSignatures(String pkg1, String pkg2) &#123;</div><div class="line">445        try &#123;</div><div class="line">446            return mPM.checkSignatures(pkg1, pkg2);</div><div class="line">447        &#125; catch (RemoteException e) &#123;</div><div class="line">448            throw new RuntimeException(&quot;Package manager has died&quot;, e);</div><div class="line">449        &#125;</div><div class="line">450    &#125;</div></pre></td></tr></table></figure></p>
<p>源文件：/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">2736    @Override</div><div class="line">2737    public int checkSignatures(String pkg1, String pkg2) &#123;</div><div class="line">2738        synchronized (mPackages) &#123;</div><div class="line">2739            final PackageParser.Package p1 = mPackages.get(pkg1);</div><div class="line">2740            final PackageParser.Package p2 = mPackages.get(pkg2);</div><div class="line">2741            if (p1 == null || p1.mExtras == null</div><div class="line">2742                    || p2 == null || p2.mExtras == null) &#123;</div><div class="line">2743                return PackageManager.SIGNATURE_UNKNOWN_PACKAGE;</div><div class="line">2744            &#125;</div><div class="line">2745            return compareSignatures(p1.mSignatures, p2.mSignatures);</div><div class="line">2746        &#125;</div><div class="line">2747    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">2799    static int compareSignatures(Signature[] s1, Signature[] s2) &#123;</div><div class="line">2800        if (s1 == null) &#123;</div><div class="line">2801            return s2 == null</div><div class="line">2802                    ? PackageManager.SIGNATURE_NEITHER_SIGNED</div><div class="line">2803                    : PackageManager.SIGNATURE_FIRST_NOT_SIGNED;</div><div class="line">2804        &#125;</div><div class="line">2805</div><div class="line">2806        if (s2 == null) &#123;</div><div class="line">2807            return PackageManager.SIGNATURE_SECOND_NOT_SIGNED;</div><div class="line">2808        &#125;</div><div class="line">2809</div><div class="line">2810        if (s1.length != s2.length) &#123;</div><div class="line">2811            return PackageManager.SIGNATURE_NO_MATCH;</div><div class="line">2812        &#125;</div><div class="line">2813</div><div class="line">2814        // Since both signature sets are of size 1, we can compare without HashSets.</div><div class="line">2815        if (s1.length == 1) &#123;</div><div class="line">2816            return s1[0].equals(s2[0]) ?</div><div class="line">2817                    PackageManager.SIGNATURE_MATCH :</div><div class="line">2818                    PackageManager.SIGNATURE_NO_MATCH;</div><div class="line">2819        &#125;</div><div class="line">2820</div><div class="line">2821        ArraySet&lt;Signature&gt; set1 = new ArraySet&lt;Signature&gt;();</div><div class="line">2822        for (Signature sig : s1) &#123;</div><div class="line">2823            set1.add(sig);</div><div class="line">2824        &#125;</div><div class="line">2825        ArraySet&lt;Signature&gt; set2 = new ArraySet&lt;Signature&gt;();</div><div class="line">2826        for (Signature sig : s2) &#123;</div><div class="line">2827            set2.add(sig);</div><div class="line">2828        &#125;</div><div class="line">2829        // Make sure s2 contains all signatures in s1.</div><div class="line">2830        if (set1.equals(set2)) &#123;</div><div class="line">2831            return PackageManager.SIGNATURE_MATCH;</div><div class="line">2832        &#125;</div><div class="line">2833        return PackageManager.SIGNATURE_NO_MATCH;</div><div class="line">2834    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="获取系统中已安装APK的签名"><a href="#获取系统中已安装APK的签名" class="headerlink" title="获取系统中已安装APK的签名"></a>获取系统中已安装APK的签名</h2><pre><code>PackageManager x = getPackageManager();
int i = x.checkSignatures(&quot;32&quot;, &quot;232&quot;);
List&lt;PackageInfo&gt; packageInfoList = x.getInstalledPackages(PackageManager.GET_SIGNATURES);
</code></pre><p>packageInfoList中每一项为一个已安装APK的相关信息，PackgeInfo类中就一项为signatures，即为该APK的签名信息</p>
<h2 id="安装APK时签名信息生成过程"><a href="#安装APK时签名信息生成过程" class="headerlink" title="安装APK时签名信息生成过程"></a>安装APK时签名信息生成过程</h2><pre><code>待续。。。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://atmzy.github.io/2016/10/17/APK安装过程中的签名校验/" data-id="cizo46p4z0000o0uo7vif6r3b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/hello/" class="article-date">
  <time datetime="2016-10-17T11:00:53.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/hello/">hello</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要:<br>
        
          <p class="article-more-link">
            <a href="/2016/10/17/hello/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://atmzy.github.io/2016/10/17/hello/" data-id="cizo46p570003o0uoqe5imjfb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/hello-world/" class="article-date">
  <time datetime="2016-10-17T10:08:16.357Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://atmzy.github.io/2016/10/17/hello-world/" data-id="cizo46p530001o0uosa7p80ct" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/27/动态加载dex-jar文件过程分析/">动态加载dex/jar文件过程分析</a>
          </li>
        
          <li>
            <a href="/2016/10/17/APK安装过程中的签名校验/">APK安装过程中的签名校验</a>
          </li>
        
          <li>
            <a href="/2016/10/17/hello/">hello</a>
          </li>
        
          <li>
            <a href="/2016/10/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 atmzy<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>